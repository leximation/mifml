// mif2mifml.c
//

/* MIFML - MIF to XML Conversion Utility
 * Copyright (C) 2004-2008 - Scott Prentice, Leximation, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * 0.13 fixes:
 * - increased XTAGVALLEN value to handle longer MathFullForm strings
 * - with multiple sequential ImportObjects the second one was not properly initialized
 * - disable multi-space handling in chartoent function .. I think this is OK .. ??
 * - included BookComponent in partial MIFML of book file
 */

#include "mifml.h"


#define XMLPAD				"    \0"
#define MAXLEVELS			20	// max nesting levels (biggest I've seen so far is 10)
#define MAXTAGLEN			60	// max tag name length (biggest I've seen so far is 32)
#define MAXLINE				1024
#define TAGVALLEN			MAXLINE
#define XTAGVALLEN			256  // was 100 .. too short for MathFullForm
#define MIFMLDTDNAME		"mifml.dtd\0"



//=============================================================================
// mif2mifml
//
int
mif2mifml(char *mifname, char *mifmlname, char *dtdpath, int opts)
{

	// OPTS:
	// 0	- Full MIFML
	// 1	- Partial MIFML - No formatting .. ??
	// partial only contains: VariableFormats, XRefFormats, AFrames, Tbls, TextFlow, and Math .. and BookComponent for books ...
	//
	// RETURN VALUES:
	//  -1	- Unable to read from MIF file
	//  -2	- Unable to write to MIFML file
	// -10  - Tagname length exceeded MAXTAGLEN
	// -11  - Current nesting level is less than -1
	// -12  - Current nesting level is greater than or equal to MAXLEVELS

// open miffile for reading
// open mifmlfile for writing
// read miffile line by line
//
// need to handle the following types of lines ..
/*
<MIFFile 7.00> # Generated by FrameMaker 7.1b023
                                  - <MIFFile version="7.00" type="<type>"
                                     description="Generated by FrameMaker 7.1b023">
<Color                            - <Color>
 <ColorTag `Black'>               - <ColorTag value="Black"/>
 <ColorCyan  0.000000>            - <ColorCyan value="0.000000"/>
 <ColorAttribute ColorIsBlack>    - <ColorCyan value="ColorIsBlack"/>
> # end of Color                  - </Color>

<String `Creating dialog box topics'>
                                  - <String>Creating dialog box topics</String>

<ImportObject
...
=<facetname>
&%<datatype>                      - <ImportObjectData facetName="<facetname>"
                                      dataType="<datatype>" value="
&\xD0CF11E0...
...                               - (direct mapping)
=EndInset                         - "/>  (close attribute)

<DocFileInfo                      - <DocFileInfo value="
...                               - (direct mapping)
> # end of DocFileInfo            - "/>  (close attribute)

<BookFileInfo                     - <BookFileInfo value="
...                               - (direct mapping)
> # end of BookFileInfo           - "/>  (close attribute)

<TextInsetEnd >                   - <TextInsetEnd />
*/

	char taglist[MAXLEVELS][MAXTAGLEN];
	FILE *miffile;
	FILE *mifmlfile;
	char line[MAXLINE];
	int i, j, itmp, out=0;
	char tagname[60];
	char tagval[TAGVALLEN];
	char strpad[60];
	char parent[60] = {"\0"};
	char mifmldtd[256];
	char tmpdesc[256];
	char mifmltype[20];					// full, partial, contentOnly
	char miftype[6] = {"\0"};			// file or book
	int inIOData = 0;
	int valtype = 0;
	int curlevel = -1;
	int maxlevels = 0;
	int maxtaglen = 0;
	char valtypename[6];
	int okwrite = 1;
	int filtered = 0;
	char xtagval[XTAGVALLEN];
	int ioDataType = 0;

	// set mifmltype
	if (opts == 1)
		strcpy(mifmltype, "partial\0");
	else
		strcpy(mifmltype, "full\0");

	// open output MIFML file for writing
	if ((mifmlfile = fopen(mifmlname, "w")) == NULL) {
		return -2;
	}
	// open input MIF file for reading
	if ((miffile = fopen(mifname, "r")) == NULL) {
		return -1;
	}
	// swap path delimiter in dtdpath
	for (i=0; i<(int)strlen(dtdpath); i++) {
		if (dtdpath[i] == '\\') dtdpath[i] = '/';
	}
	// based on dtdpath value, set mifmldtd
	if (strcmp(dtdpath, ".\0") == 0)
		sprintf(mifmldtd, MIFMLDTDNAME);
	else
		sprintf(mifmldtd, "file:///%s/%s", dtdpath, MIFMLDTDNAME);

	// start writing to mifml file ..
	fprintf(mifmlfile, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n\0");
	fprintf(mifmlfile, "<!-- Generated with %s v.%s %s - %s -->\n\0", MIF2MIFMLAPPNAME,
		MIF2MIFMLVER, MIF2MIFMLCREATOR, MIFMLURL);

	// read lines from MIF file until EOF
	while (! feof(miffile)) {
		fgets(line, sizeof(line), miffile);
		strtok(line, "\n"); 	// strip \n
		strtok(line, "\r");		// strip \r

		if (line[0] == '#') continue;	// if starts with # .. skip the comment

		// count leading spaces to indent MIFML
		i = 0;
		strcpy(strpad, "\0");
		while (line[i++] == ' ') {
			sprintf(strpad, "%s%s\0", strpad, XMLPAD);
		}
		// roll back one char
		i--;

		// next char should be a "<" or ">" .. if not, skip it
		if (line[i] == '<') {			// start tag or item
			i++;

			// while not a space or EOL, build tagname
			strcpy(tagname, "\0");
			while ((line[i] != ' ') && (line[i] != '\0')) {
				sprintf(tagname, "%s%c\0", tagname, line[i]);
				i++;
			}
			// check length of tagname
			j = strlen(tagname);
			if (j >= MAXTAGLEN) {
				fclose(miffile);
				fclose(mifmlfile);
				return -10;
			}
			// track the largest tag name
			if (j > maxtaglen ) maxtaglen = j;

			itmp = 0;
			while (line[i++] == ' ') itmp++; // gobble up more space
			i--; // roll back one char

			// go to end of line and work backwards to find closing '>'
			j = strlen(line);
			if (i < j) {  // for open elem, i will equal j
				// work backwards through j to find closing '>'
				while ((line[j] != '>') && ( j != 0)) j--;
				if (j == 0) {
					// if no '>' found, and if this is a MathFullForm, reset j to end of line
					if (strcmp(tagname, "MathFullForm\0") == 0) {
						j = strlen(line);
					}
					else {
						printf("> WARNING: Invalid syntax on line %d .. no closing '>'!\n", out);
						continue; // bail .. this *shouldn't* happen .. ??
					}
				}
				if (j == i) {					// null value
					valtype = 0;
				}
				else if (line[i] == '`') {		// string value
					valtype = 1;
					strcpy(valtypename, "str\0");
					i++;						// increment into string value
					j--;						// decrement before closing "'"
				}
				else if (itmp == 2) {			// 2 spaces after the tag name .. numeric value (??)
					valtype = 2;
					strcpy(valtypename, "num\0");
				}
				else {							// else, must be enum value
					valtype = 3;
					strcpy(valtypename, "enum\0");
				}

				// extract tagval from line .. convert special chars to entities
				strcpy(tagval, "\0");
				if (chartoent(line, tagval, i, j, MAXLINE) < 0) {
					printf("> WARNING: Bad entity conversion on line %d !\n", out);
				}
				if ((strcmp(tagname, "MIFFile\0") == 0) || (strcmp(tagname, "Book\0") == 0)) {
					int k, ok=0;
					if (strcmp(tagname, "MIFFile\0") == 0) strcpy(miftype, "file\0");
					else strcpy(miftype, "book\0");
					strcpy(tmpdesc, "\0");
					for (k=0; k<(int)strlen(line); k++) {
						if (ok == 1) {
							sprintf(tmpdesc, "%s%c\0", tmpdesc, line[k]);
						}
						if (line[k] == '#') {
							ok = 1;
							while (line[++k] == ' ') { } // strip leading spaces
							k--;
						}
					}
					if (strcmp(miftype, "book\0") == 0) {
						fprintf(mifmlfile, "<!DOCTYPE MIFBook SYSTEM \"%s\">\n\0", mifmldtd);
						fprintf(mifmlfile, "<MIFBook version=\"%s\" export-type=\"%s\" description=\"%s\">\n\0",
							tagval, mifmltype, tmpdesc);
					}
					else {
						fprintf(mifmlfile, "<!DOCTYPE MIFFile SYSTEM \"%s\">\n\0", mifmldtd);
						fprintf(mifmlfile, "<MIFFile version=\"%s\" export-type=\"%s\" description=\"%s\">\n\0",
							tagval, mifmltype, tmpdesc);
					}
				}
				else if (strcmp(tagname, "String\0") == 0) {
					if (okwrite == 1) {
						fprintf(mifmlfile, "%s%s<%s>%s</%s>\n\0", XMLPAD, strpad, tagname, tagval, tagname);
					}
				}
				else if (strcmp(tagname, "MathFullForm\0") == 0) {
					if (okwrite == 1) {
						strcpy(xtagval, "\0");
						if (chartoent(line, xtagval, i, 0, XTAGVALLEN) < -1) {
							printf("> WARNING: Bad entity conversion on line %d !\n", out);
						}
						fprintf(mifmlfile, "%s%s<%s value=\"%s\0", XMLPAD, strpad, tagname, xtagval);
					}
				}
				else if (valtype == 0) {
					if (okwrite == 1) {
						fprintf(mifmlfile, "%s%s<%s />\n\0", XMLPAD, strpad, tagname);
					}
				}
				else {
					if(okwrite == 1) {
						fprintf(mifmlfile, "%s%s<%s value=\"%s\" type=\"%s\"/>\n\0",
							XMLPAD, strpad, tagname, tagval, valtypename);
					}
				}
			}
			else {
				// if "partial" check for appropriate sections
				// VariableFormats, XRefFormats, AFrames, Tbls, TextFlow, and Math
				if (opts == 1) {
					if (curlevel == -1) {
						if ((strcmp(tagname, "VariableFormats\0")==0) ||
							(strcmp(tagname, "XRefFormats\0")==0) ||
							(strcmp(tagname, "AFrames\0")==0) || (strcmp(tagname, "Tbls\0")==0) ||
							(strcmp(tagname, "TextFlow\0")==0) || (strcmp(tagname, "Math\0")==0) ||
							(strcmp(tagname, "BookComponent\0")==0)) {
							okwrite = 1;
						}
						else {
							okwrite = 0;
						}
					}
				}
				else
					okwrite = 1;

				// simple opening element
				if (okwrite == 1) {
					if (strcmp(tagname, "DocFileInfo\0") == 0) {
						fprintf(mifmlfile, "%s%s<%s value=\"\n\0", XMLPAD, strpad, tagname);
					}
					else if (strcmp(tagname, "BookFileInfo\0") == 0) {
						fprintf(mifmlfile, "%s%s<%s value=\"\n\0", XMLPAD, strpad, tagname);
					}
					else {
						fprintf(mifmlfile, "%s%s<%s>\n\0", XMLPAD, strpad, tagname);
					}
				}
				strcpy(parent, tagname);
				curlevel++;
				if (curlevel >= MAXLEVELS) {
					fclose(miffile);
					fclose(mifmlfile);
					return -12;
				}
				strcpy(taglist[curlevel], tagname);
				if (curlevel > maxlevels) maxlevels = curlevel;
			}
		}
		// closing tag
		else if( line[i] == '>' ) {
			strcpy(tagname, taglist[curlevel]);
			if (okwrite == 1) {
				if (strcmp(tagname, "DocFileInfo\0") == 0) {
					fprintf(mifmlfile, "\" type=\"val\"/>\n\0");
				}
				else if (strcmp(tagname, "BookFileInfo\0") == 0) {
					fprintf(mifmlfile, "\" type=\"val\"/>\n\0");
				}
				else {
					fprintf(mifmlfile, "%s%s</%s>\n\0", XMLPAD, strpad, tagname);
				}
			}
			curlevel--;
			if (curlevel < -1) {
				fclose(miffile);
				fclose(mifmlfile);
				return -11;
			}
			// re-enable "okwrite" if disabled for "partial" MIFML
			if (curlevel == -1) {
				okwrite = 1;
			}
		}
		// child data
		else if (strcmp(tagname, "DocFileInfo\0") == 0) {
			// write DocFileInfo data
			if (okwrite == 1) {
				fprintf(mifmlfile, "%s\n\0", line);
			}
		}
		else if (strcmp(tagname, "BookFileInfo\0") == 0) {
			// write BookFileInfo data
			if (okwrite == 1) {
				fprintf(mifmlfile, "%s\n\0", line);
			}
		}
		else if (strcmp(tagname, "MathFullForm\0") == 0) {
			strcpy(xtagval, "\0");
			// write MathFullForm data
			if (line[strlen(line)-1] == 39) { // if single quote .. the end
				if (chartoent(line, xtagval, 0, strlen(line)-1, XTAGVALLEN) < -1) {
					printf("> WARNING: Bad entity conversion on line %d !\n", out);
				}
				fprintf(mifmlfile, "%s\" type=\"str\" />\n\0", xtagval);
				// eat next line ??
				fgets( line, sizeof( line ), miffile );
			}
			else { // must be after the start but before the end ..
				if (chartoent(line, xtagval, 0, 0, XTAGVALLEN) < -1) {
					printf("> WARNING: Bad entity conversion on line %d !\n", out);
				}
				fprintf(mifmlfile, "%s\0", xtagval);
			}
		}
		else if ((strcmp(parent, "ImportObject\0") == 0) &&
			((line[i] == '=') || (line[i] == '&'))) {
			// write ImportObjectData data
			if ((line[i] == '=') && (inIOData == 0)) {
				strcpy(tagval, "\0");
				i++;
				while (i < (int)strlen(line)) {
					sprintf(tagval, "%s%c\0", tagval, line[i++]);
				}
				if (okwrite == 1) {
					fprintf(mifmlfile, "%s%s<ImportObjectData facetName=\"%s\" \0",
						XMLPAD, strpad, tagval);
				}
				inIOData = 1;
				ioDataType = 0; // this should have already been set .. ???
			}
			else if ((line[i] == '&') && (line[i+1] == '%') &&
				(inIOData == 1) && (ioDataType == 0)) {
				// &%<datatype>
				if (okwrite == 1) {
					fprintf(mifmlfile, "dataType=\"%c\" value=\"\n\0", line[i+2]);
				}
				ioDataType = 1; // only write this once per facet
			}
			else if ((line[i] == '=') && (inIOData == 1)) {
				// =EndInset .. or more facets
				strcpy(tagval, "\0");
				i++;
				while (i < (int)strlen(line)) {
					sprintf(tagval, "%s%c\0", tagval, line[i++]);
				}
				if (strcmp(tagval, "EndInset\0") == 0) {
					if (okwrite == 1) {
						fprintf(mifmlfile, "\" type=\"val\" flag=\"endinset\"/>\n\0"); // no padding
					}
					inIOData = 0;
				}
				else {
					if (okwrite == 1) {
						fprintf(mifmlfile, "\" type=\"val\" flag=\"facet\"/>\n\0"); // no padding
						fprintf(mifmlfile, "%s%s<ImportObjectData facetName=\"%s\" \0",
							XMLPAD, strpad, tagval);
						ioDataType = 0;  // reset flag
					}
				}
			}
			else {
				// replace '&' with '&amp;'
				strcpy(tagval, "\0");
				if (chartoent(line, tagval, 0, 0, TAGVALLEN) < -1) {
					printf("> WARNING: Bad entity conversion on line %d !\n", out);
				}
				if (okwrite == 1) {
					fprintf(mifmlfile, "%s\n\0", tagval);
				}
			}
		}
		else {
			if(strcmp(line, "\0") != 0) {
				// read next lines until ">" is found ???

				//skip this line ?? .. write it out as plain text
				if (okwrite == 1) {
					if (hascontent(line) == 1)
						fprintf(mifmlfile, "<!-- IGNORING: [%s] -->\n\0", line);
				}
			}
		}
		out++;
		if (okwrite == 0) filtered++;
	}
	if (strcmp(miftype, "book\0") == 0) {
		fprintf(mifmlfile, "</MIFBook>\n\0");
	}
	else {
		fprintf(mifmlfile, "</MIFFile>\n\0");
	}
	fprintf(mifmlfile, "<!--  maxlevels: %d;  maxtaglen: %d -->\n\0", maxlevels, maxtaglen);

	fclose(miffile);
	fclose(mifmlfile);

	if (opts == 1) printf( "\n> %d lines filtered out for partial MIFML\n", filtered);

	return out;
}

